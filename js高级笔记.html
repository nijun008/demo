<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>js高级笔记</title>
  </head>
  <body>
    <script>
      let arr = [undefined, null, 123, '23', () => ({}), function () {console.log("??")} ,true, 'true', '']

      console.log(arr)

      let clone  = JSON.parse(JSON.stringify(arr))

      // undefined 函数 会转换为null
      console.log(clone)
      // 变量的名称存在栈里面
      
      // 函数
      function Fn () {
        
      }

      Fn.prototype.test = function () {
        console.log(this)
      }

      // 函数默认拥有prototype属性，为一个空对象
      console.log(Fn.prototype) // {}
      // 函数的prototype有constructor方法，构造方法为函数自身
      console.log(Fn.prototype.constructor === Fn) // true
      
      Fn.prototype.testEnd = function () {
        console.log(this)
      }
      // 实例对象的__proto__就是类的prototype
      let f = new Fn()
      console.log(f.__proto__ === Fn.prototype)

      // 所有函数都是Function的实例，包括Function自身
      console.log(Function instanceof Object, '???')
      console.log(Function.__proto__ === Function.prototype)
      console.log(Object.__proto__=== Function.prototype)
      console.log(new Object())



      function Fn2 (name) {
        this.name = name
      }
      Fn2.prototype.n = 1
      let a = new Fn2() // a.__proto__为初始的Fn2 proptotype
      // 重写Fn2原型，与原有原型断开
      Fn2.prototype = {
        n: 2,
        m: 3
      }
      // b.__proto__ = { n:2, m: 3 }
      let b = new Fn2()
      // 重写类的原型不影响原有实例的__proto__
      console.log('a :', a.n, a.m) // 1 undefined
      console.log('b :', b.n, b.m) // 2, 3
    </script>
  </body>
</html>